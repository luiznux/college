.\" to run-off, use: tbl doc | troff -ms
.so macros
.nr a 1
.B
.ce 2
The MINIX ANSI C, Modula-2, and Pascal compiler
.nr d 1
.sp 1
.PP
This package contains the executable binaries of the
.MX
ANSI C compiler, the
.MX
Modula-2 compiler, and the
.MX
Pascal compiler.
This document describes how to install the compilers
and its associated libraries and utilities, and also describes how to use them.
.NH 1
INSTALLATION INSTRUCTIONS
.PP
This package consists of seventeen executable programs for the PC-version and
sixteen for the 68000 versions of \*(Mx.  It also contains several libraries
and the sources for these libraries.
The compiler is called by a driving program called \fIncc\fR.  This program
invokes ten other programs on \*(Mp and eight on the 68000 version of \*(Mx.
For \*(Mp, they are: \fIncpp\fR, \fIirrel\fR, \fIncem\fR, \fInm2em\fR,
\fInpem\fR, \fInopt\fR,
\fIncg\fR, \fIas\fR, \fIld\fR,\fR and \fIcv\fR.  For the 68000 versions
of \*(Mx, \fIncpp\fR and \fIirrel\fR are not called.  All of these
except \fIas\fR belong in \fI/usr/lib\fR; \fIas\fR goes in \fI/usr/bin\fR.
In addition, this package includes a new archiver, \fIaal\fR, for making
libraries, and a Modula-2 Makefile generator, \fIm2mm\fR.
It also contains some utilities for handling ACK format object files:
\fIanm\fP, \fIastrip\fP, \fIasize\fP, and \fIaoutdump\fP.
Unlike the old \*(Mp archiver, \fIar\fR, \fIaal\fR builds an index
for each library, so the order of the files in the archive is no longer
relevant.  This archiver is the same as \fIar\fR on the 68000 versions of
\*(Mx.
.PP
In addition to these programs, this package also contains eight libraries
as follows:
.HS
.ta 1.5i
   /usr/lib/libd.A	Decreases program size when no floating point is used
.br
   /usr/lib/libe.A	Internal compiler routines
.br
   /usr/lib/libc.A	ANSI C library, system calls, and other routines
.br
   /usr/lib/libp.A	Pascal library
.br
   /usr/lib/libm2.A	Modula-2 library
.br
   /usr/lib/libfp.A	Floating point library
.br
   /usr/lib/libs.A	Assembly version of string routines, available with \fI\(enls\fP
.br
   /usr/lib/end.A	Contains end, etext, and edata
.HS
All of these should be installed in \fI/usr/lib\fR.
Note that the recommended convention is to use the suffix \fI.A\fR for
new-style libraries, to avoid confusion with the old-style libraries.
The old and new library formats are not compatible, but they
may co-exist in the same directory.
.PP
The package also contains some example programs written in ANSI C, Modula-2,
and Pascal. See the \fIexamples\fP sub-directory.
.PP
The library sources consist of a shell-script, compressed files and
archives of compressed files.  The shell-script (called \fIunpacklibs\fR) can
be used to unpack and decompress the archives.
.PP
To install the compilers on a hard disk, boot
.MX
and create an empty directory.
Next, mount the first diskette and use \fIcpdir\fR to copy its contents
to this directory.
When done, unmount the diskette.  For 3.5 inch disks or 5.25 inch 360K disks,
mount the next one, and repeat the procedure. 
For the 5.25 inch AT version you need to copy only one disk,
for the 5.25 inch PC version you need to copy four disks,
and for the 3.5 inch versions you need to copy two disks.
Next, run the \fIunpackbins\fR shell script.
This script takes care of the decompressing and de-archiving.
Next, copy files from 
\fIbin\fR to \fI/usr/bin\fR,
files from \fIlib\fR to \fI/usr/lib\fR, etc.
Also, move \fI/usr/include\fR to \fI/usr/include.old\fR, and move 
\fIinclude\fR to \fI/usr/include\fR.
.PP
Some shell scripts, Makefiles, etc. need cpp.
However, the new pre-processor
is called \fIncpp\fR.
If you don't leave the old one around,
you should link \fI/usr/lib/cpp\fR to \fI/usr/lib/ncpp\fR.
.PP
To make the Modula-2 compiler
available, link \fI/usr/bin/m2\fR to \fI/usr/bin/ncc\fR.  To make the
Pascal compiler available, link \fI/usr/bin/pc\fR to \fI/usr/bin/ncc\fR.
.PP
At this point you will have the old C compiler available as \fIcc\fR
and the new one available as \fIncc\fR.
If you want to be able to run both compilers, you can keep it like this.
Otherwise, copy \fI/usr/bin/cc\fR to \fI/usr/bin/occ\fR (old \fIcc\fR),
and copy \fI/usr/bin/ncc\fR to \fI/usr/bin/cc\fR.
Unfortunately, if you attempt to run the old compiler as \fIocc\fR,
it will give an error message, because the old driver expects to be called
\fIcc\fR.
You will have to copy it to \fI/usr/bin/cc\fR
first.
The new C compiler does work when called \fIncc\fR, though.
.PP
The source of \fIcc\fR has been provided, so you can change the path names
where the various passes and libraries are expected.
.PP
Now you are ready to try the compiler: go to the \fIexamples\fP sub-directory
and try to compile the example programs: f.i.:
.DS
ncc factor.c
.DE
or
.DS
m2 cp.mod
.DE
.PP
The library sources reside in the \fIsrc\fP sub-directory.
You can use the shell-script \fIunpacklibs\fR to de-archive and de-compress
the files needed.  When this script is finished,
you can call \fIMakelibs\fR in each of the \fIlibc\fR, \fIlibp\fR,
\fIlibm2\fR, and \fIlibs\fP directories.  In order for \fIMakelibs\fR to succeed, you must have
installed the compilers and the archiver first.  Furthermore, you will need
enough memory to run \fIsh\fR, \fImake\fR, \fIcc\fR and the front-end at the same time.
If memory is tight, you can give the command '. \fIMakelibs\fR', which causes the
current shell to interpret the script.  You will also need enough space in
\fI/tmp\fR to hold \fIlibc.A\fR, since the archiver uses \fI/tmp\fR to create the library.
About 200K should suffice.
.NH 1
COMPARISON OF ANSI C WITH K&R C
.PP
The
.MX
ANSI C compiler is based on ANS X3.159-1989 and will compile strictly conforming C
programs (except programs that are so large that the compiler runs out of
internal space).
.PP
The new (ANSI) compiler differs from the old (K&R) compiler in many
ways.
Most of these are positive:
.IP \(bu
The compiler and preprocessor accept ANSI C instead of K&R C.
.IP \(bu
The optimizer and the code-generator are improved.
.IP \(bu
On \*(Mp, the compiler produced packed \fI.s\fR files.
It now produces \fI.o\fR files.
On the 68000 \*(Mx versions, the compiler already produced \fI.o\fR files.
.IP \(bu
On \*(Mp, linking is much faster since a true linker (\fIld\fR) is
provided and it uses the ranlib mechanism.
This was already used on the 68000 versions of \*(Mx.
.IP \(bu
Floating point is supported, by means of emulation.
For \*(Mp, the 8087 is also supported, and for the 68000 versions of \*(Mx
the M68881 is also supported.
However, as the current (1.5.10) version of
the \*(Mx kernel does not support these floating point processors,
floating point emulation should be used.
.IP \(bu
On \*(Mp, the compiler can handle larger programs, if they are broken up
into medium-sized files.  The new linker rarely runs out of space, as the
old one did on large programs.
.PP
However, there are also a few differences that are negative.
.IP \(bu
The compilation process needs more passes.
.IP \(bu
The executables will generally be larger than those compiled with the old
compiler due to the presence of ANSI libraries which are large and
complicated due to requirements imposed by the standard.
.IP \(bu
The \*(Mp assembler has a different syntax.
However, the new syntax is compatible with the \s-2XENIX\s0 assembler.
A shell script for doing conversion between the old and new assembly
languages is provided.  Although this script is not perfect, it will make
most of the conversions.
.IP \(bu
The compiler uses more memory than the old one, mainly because storing
the prototypes of the header files requires space inside the compiler.
For the \*(Mp there is an option that causes unused prototypes to be
removed.  This may have some side-effects.
.de NS
.br
.ne 4
.sp 1v-\\n(PDu
.in 0
\\fBANS \\$1:\\fR
..
.NH 1
ANSI C REPORT
.PP
This section specifies the implementation-defined behavior of the ANSI-C
compiler as required by ANS X3.159-1989.
.NS A.6.3.1
.IP \(bu
Diagnostics are placed on the standard error output.  They have the
following specification:
.DS
"<file>", line <nr>: [(<class>)] <diagnostic>
.DE
There are three classes of diagnostics: 'error', 'strict' and 'warning'.
When the class is 'error', the class specification is absent.
The class 'strict' is used for violations of the standard which are
not severe enough to stop compilation, for example the occurrence
of non white-space after an '#endif' preprocessing
directive.  The class 'warning' is used for legal but dubious
constructions, for example the declaration of a structure-tag in a
parameter type list.
.NS A.6.3.2
.IP \(bu
The function 'main' can have zero or two parameters.  When it has two
parameters, the first parameter is an integer specifying the number of
arguments on the command line (including the command).  The second
parameter is a pointer to an array of pointers to the arguments
(as strings).
.IP \(bu
Interactive devices are terminals.
.NS A.6.3.3
.IP \(bu
The number of significant characters is 64.
Corresponding upper-case and lower-case letters are different.
.NS A.6.3.4
.IP \(bu
The compiler assumes ASCII-characters in both the source and execution
character set.
.IP \(bu
There are no multibyte characters.
.IP \(bu
There are 8 bits in a character.
.IP \(bu
Character constants that cannot be represented in 8 bits
are truncated.
.IP \(bu
Character constants that are more than 1 character wide will have the
first character specified in the least significant byte.
.IP \(bu
The only supported locale is 'C'.
.IP \(bu
A plain 'char' has the same range of values as 'signed char'.
.NS A.6.3.5
.IP \(bu
The i80x86 and 68000 both have a two's complement binary-number system.
Both ints and shorts are 2 bytes; longs occupy 4 bytes.
.IP \(bu
Converting an integer to a shorter signed integer is implemented by
ignoring the high-order byte(s) of the former.
Converting a unsigned integer to a signed integer of the same type is
only done in administration.  This means that the bit-pattern remains
unchanged.
.IP \(bu
The result of bitwise operations on signed integers are what can be
expected on a two's complement machine.
.IP \(bu
When either operand is negative, the result of the / operator is the
largest integer less than or equal to the algebraic quotient.
The sign of the remainder on integer division is the sign of the
enumerator.
.IP \(bu
The right-shift of a negative value is negative.
.NS A.6.3.6
.IP \(bu
The compiler uses IEEE format for floating-point numbers.
High-precision floating-point is used for constant folding.
.IP \(bu
Truncation is done to the nearest floating-point number that can
be represented.
.NS A.6.3.7
.IP \(bu
The type of the sizeof-operator (also known as size_t) is 'unsigned int'.
.IP \(bu
Casting an integer to a pointer or vice versa has no effect in
bit-pattern when the sizes are equal.  Otherwise the value will be
truncated or zero-extended (depending on the direction of the
conversion and the relative sizes).
.IP \(bu
The type of a 'ptrdiff_t' is 'int' on \*(Mp, and 'long' on the 68000
\*(Mx versions.
.NS A.6.3.8
.IP \(bu
Since the front end has only limited control over the registers, it can
only make it more likely that variables that are declared as
registers also end up in registers.  The only things that can possibly be
put into registers are plain ints and pointers.
.NS A.6.3.9
.IP \(bu
When a member of a union object is accessed using a member of a
different type, the resulting value will usually be garbage.  The
compiler makes no effort to catch these errors.
.IP \(bu
The alignment of types is 1 byte for characters and 2 bytes for all other
types.
.IP \(bu
A plain 'int' bit-field is taken as a 'signed int'.  This means that
a field with a size 1 bit-field can only store the values 0 and \(mi1.
.IP \(bu
In bit-fields, high-order bits are allocated first.
.IP \(bu
An enum has the same size as a plain 'int'.
.NS A.6.3.10
.IP \(bu
An access to a volatile object is either a load or a store.  Just
mentioning a volatile variable is not enough.
E.g. the statement 'x;' where x is declared volatile, does not
constitute an access.  When a volatile object should be read, but its
value ignored, 'if (x);' should do the trick.
.NS A.6.3.11
.IP \(bu
There is no fixed limit on the number of declarators that may modify an
arithmetic, structure or union type, although specifying too many may
cause the compiler to run out of memory.
.NS A.6.3.12
.IP \(bu
The maximum number of cases in a switch-statement is in the order of
1e9, although the compiler may run out of memory somewhat earlier.
.NS A.6.3.13
.IP \(bu
Since both the preprocessor and the compiler assume ASCII-characters, 
a single character constant in a conditional-inclusion directive
matches the same value in the execution character set.
.IP \(bu
The preprocessor recognizes \fI\(enI...\fR command-line options.  The
directories thus specified are searched first.  After that, /usr/include is
visited.
.IP \(bu
Quoted names are first looked for in the directory in which the file
which does the include resides.
.IP \(bu
The characters in a h- or q- char-sequence are taken to be
.UX
paths.
.IP \(bu
Neither the front-end nor the preprocessor know any pragmas.
.IP \(bu
Since the compiler runs on 
.MX ,
_\^_DATE_\^_ and _\^_TIME_\^_ will always be
defined.
.NS A.6.3.14
.IP \(bu
NULL is defined as ((void *)0).  This in order to detect dubious
constructions like 'int x = NULL;'.
.IP \(bu
The diagnostic printed by 'assert' is as follows:
.DS
Assertion "<expr>" failed, file "<file>", line <line>
.DE
where <expr> is the argument to the assert macro, printed as string.
(the <file> and <line> should be clear)
.IP \(bu
The sets for character test macros are as follows:
.sp \n(PDu
.TS H
center allbox;
l l.
\fBName	Set\fR
_
.TH
\fIisalnum\fR	0-9A-Za-z
\fIisalpha\fR	A-Za-z
\fIiscntrl\fR	\e000-\e037\e177
\fIislower\fR	a-z
\fIisupper\fR	A-Z
\fIisprint\fR	\e040-\e176
.TE
.sp \n(PDu
As an addition, there is an \fIisascii\fR macro, which tests whether a character
is an ASCII character.  Characters in the range from \e000 to \e177 are ASCII
characters.
.IP \(bu
The behavior of mathematical functions on domain error is as follows:
.sp \n(PDu
.TS H
center allbox;
l c
l n.
\fBName	Returns\fR
_
.TH
\fIasin\fR	0.0
\fIacos\fR	0.0
\fIatan2\fR	0.0
\fIfmod\fR	0.0
\fIlog\fR	\(miHUGE_VAL
\fIlog10\fR	\(miHUGE_VAL
\fIpow\fR	0.0
\fIsqrt\fR	0.0
.TE
.sp \n(PDu
.IP \(bu
Underflow range errors do not cause \fIerrno\fR to be set.
.IP \(bu
The function \fIfmod\fR returns 0.0 and sets \fIerrno\fR to EDOM when the second
argument is 0.0.
.IP \(bu
The set of signals for the \fIsignal\fR function is as follows:
.sp \n(PDu
.TS H
center allbox;
l l.
\fBSignal	Description\fR
_
.TH
SIGHUP	hangup
SIGINT	interrupt (DEL)
SIGQUIT	quit (ASCII FS)
SIGILL	illegal instruction
SIGTRAP	trace trap (not reset when caught)
SIGABRT	IOT instruction
SIGIOT	SIGABRT for people who speak PDP-11
SIGUNUSED	spare code
SIGFPE	floating point exception
SIGKILL	kill (cannot be caught or ignored)
SIGUSR1	user defined signal # 1
SIGSEGV	segmentation violation
SIGUSR2	user defined signal # 2
SIGPIPE	write on a pipe with no one to read it
SIGALRM	alarm clock
SIGTERM	software termination signal from kill
SIGSTKFLT	used by kernel to indicate stack fault
.TE
.sp \n(PDu
The default handling is not reset when SIGILL is received.
.IP \(bu
A text-stream need not end in a new-line character.
.IP \(bu
White space characters before a new-line appear when read in.
.IP \(bu
There may be any number of null characters appended to a binary
stream.
.IP \(bu
The file position indicator of an append mode stream is initially
positioned at the beginning of the file.
.IP \(bu
A write on a text stream does not cause the associated file to be
truncated beyond that point.
.IP \(bu
The buffering intended by the standard is fully supported.
.IP \(bu
A zero-length file actually exists.
.IP \(bu
A file name can consist of any character, except for the '\e0' and
the '/'.
.IP \(bu
A file can be open multiple times.
.IP \(bu
When a \fIremove\fR is done on an open file, reading and writing behave
just as can be expected from a non-removed file.  When the associated
stream is closed, however, all written data will be lost.
.IP \(bu
When a file exists prior to a call to \fIrename\fR, it is removed.
.IP \(bu
The %p conversion in \fIfprintf\fR has the same effect as %#x on \*(Mp and
%#lx on the 68000 versions of \*(Mx.
.IP \(bu
The %p conversion in \fIfscanf\fR has the same effect as %x on \*(Mp and
%lx on the 68000 versions of \*(Mx.
.IP \(bu
A \(mi character that is neither the first nor the last character in the
scanlist for %[ conversion is taken to be a range indicator.  When the
first character has a higher ASCII-value than the second, the \(mi will
just be put into the scanlist.
.IP \(bu
The value of \fIerrno\fR when \fIfgetpos\fR or \fIftell\fR failed is that of \fIlseek\fR.
This means:
.TS
l l.
EBADF \-	when the stream is not valid
ESPIPE \-	when fildes is associated with a pipe
EINVAL \-	the resulting file pointer would be negative
.TE
.IP \(bu
The messages generated by \fIperror\fR depend on the value of \fIerrno\fR.
The mapping of errors to strings is done by \fIstrerror\fR.
.IP \(bu
When the requested size is zero, \fImalloc\fR, \fIcalloc\fR and \fIrealloc\fR
return a null-pointer.
.IP \(bu
When \fIabort\fR is called, output buffers will be flushed.  Temporary files
(made with the \fItmpfile\fR function) will have disappeared when SIGABRT
is not caught or ignored.
.IP \(bu
The \fIexit\fR function returns the low-order eight bits of its argument
to the environment.
.IP \(bu
The predefined environment names are controlled by the user.
Setting environment variables is done through the \fIputenv\fR function.
This function accepts a pointer to char as its argument.
To set, for example, the environment variable TERM to a230 one writes
.DS
static char terminal[] = "TERM=a230";
putenv(terminal);
.DE
The argument to \fIputenv\fR is stored in an internal table, so malloc'ed
strings cannot be freed until another call to \fIputenv\fR (which sets the
same environment variable) is made.  The argument to \fIputenv\fR must be
writable, which means that officially, the argument cannot be a string
constant.
The function returns 1 if it fails, 0 otherwise.
.LP
.IP \(bu
The argument to \fIsystem\fR is passed as argument to \fI/bin/sh \(enc\fR.
.IP \(bu
The strings returned by \fIstrerror\fR depend on \fIerrno\fR in the following
way:
.sp \n(PDu
.TS H
center allbox;
l l.
\fBErrno	String\fR
_
.TH
0	"Error 0"
EPERM	"Not owner"
ENOENT	"No such file or directory"
ESRCH	"No such process"
EINTR	"Interrupted system call"
EIO	"I/O error"
ENXIO	"No such device or address"
E2BIG	"Arg list too long"
ENOEXEC	"Exec format error"
EBADF	"Bad file number"
ECHILD	"No children"
EAGAIN	"No more processes"
ENOMEM	"Not enough core"
EACCES	"Permission denied"
EFAULT	"Bad address"
ENOTBLK	"Block device required"
EBUSY	"Mount device busy"
EEXIST	"File exists"
EXDEV	"Cross-device link"
ENODEV	"No such device"
ENOTDIR	"Not a directory"
EISDIR	"Is a directory"
EINVAL	"Invalid argument"
ENFILE	"File table overflow"
EMFILE	"Too many open files"
ENOTTY	"Not a typewriter"
ETXTBSY	"Text file busy"
EFBUG	"File too large"
ENOSPC	"No space left on device"
ESPIPE	"Illegal seek"
EROFS	"Read-only file system"
EMLINK	"Too many links"
EPIPE	"Broken pipe"
EDOM	"Math argument"
ERANGE	"Result too large"
EDEADLK	"Resource deadlock avoided"
ENAMETOOLONG	"File name too long"
ENOLCK	"No locks available"
ENOSYS	"Function not implemented"
ENOTEMPTY	"Directory not empty"
.TE
.sp \n(PDu
Everything else causes \fIstrerror\fR to return "unknown error".
.IP \(bu
The local time zone is per default GMT.  This can be
changed through the TZ environment variable, e.g. TZ=EST6.
.IP \(bu
The \fIclock\fR function returns the number of ticks since process
startup.
.SH
References
.IP [1]
ANS X3.159-1989
.I
American National Standard for Information Systems -
Programming Language C
.R
.NH 1
RECOMPILING MINIX WITH THE ANSI C COMPILER
.PP
Several changes are required to recompile
.MX
1.5 with the ANSI C compiler:
.IP 1.
On the PC versions of
.MX
the \fImake\fR program needs to be recompiled without the \(enDMINIX_PC
option, to reflect the fact that the compiler now produces .o files.
.IP 2.
On the PC versions of
.MX
most Makefiles must be changed, again 
to reflect the fact that the compiler now produces .o files.
.IP 3.
\fItools/init.c\fR redefines \fIsbrk\fR.
For the ANSI C compiler, this should
be \fI_sbrk\fR (with an underscore).
.IP 4.
On the PC versions of
.MX
\fItools/menu1.s\fR defines \fI_exit\fR.
It should also define \fI__exit\fR
at the same position.
.IP 5.
In \fItools/init.c\fR, the call to \fIstartup\fR is wrong: the first parameter
should be cast to an \fIint\fR.
.IP 6.
The library routine \fIprintk\fR now uses \fIputk\fR instead of \fIputc\fR.
In \fIfs\fR, \fIkernel\fR, and \fImm\fR, the definition of \fIputc\fR must
be replaced by \fIputk\fR.
.IP 7.
On the PC versions of
.MX
the assembler syntax has changed.
To recompile the kernel, the
files with a .x extension therefore must be replaced by the result of
\fIsconv\fR, f.i.:
.DS
mv mpx.x mpx.x.old
sconv < mpx.x.old > mpx.x
.DE
This also holds for the .s files in the \fItools\fR directory.
In addition, the
assembler directives \fI.word\fR and \fI.byte\fR, used in the file
\fIkernel/sconst.h\fR must be changed to \fI.data2\fR and \fI.data1\fR
respectively.
.IP 8.
The use of %D and %O in printf is strongly discouraged.
They will only work
if printf is redefined as printk, because printf now obeys the ANSI C rules
(which do not contain %D and/or %O).
Also, the semantics of %X has changed:
it now means that upper case letters must be used instead of lower case;
an \fIint\fR is printed, not a \fIlong\fR.
To print a \fIlong\fR, use
%lx or %lX.
.IP 9.
Because all of
.MX
1.5
is written in 'old-fashioned' C, the \fI\(enwo\fR option should be added to
CFLAGS.
.IP 10.
Most of the commands can be recompiled without changes.
However, some 
commands require changes and/or special compiler flags:
.RS
.IP \(bu
all programs that include <signal.h> should, when compiled with \(enD_POSIX_SOURCE,
first include <sys/types.h>.
.IP \(bu
On \*(Mp, fsck.c requires the \fI\(enm\fR option, due to its large size.
.IP \(bu
leave.c uses an external variable \fItimezone\fR.
This should be changed
to \fI_timezone\fR (note the underscore).
.IP \(bu
roff.c contains a declaration of \fIsprintf\fR.
It should be removed.
.IP \(bu
patch contains a declaration of \fIsprintf\fR.
It should be removed.
.IP \(bu
elvis/regexp.c should declare \fIstrchr\fR globally.
.RE
.NH 1
THE MINIX MODULA-2 COMPILER
.PP
This section describes the implementation-specific features of the
.MX
Modula-2 compiler.
It is not intended to teach Modula-2 programming.
For a description of the Modula-2 language,
the reader is referred to [1].
.SH
The language implemented
.PP
This paragraph discusses the deviations from the Modula-2 language as described
in the 'Report on The Programming Language Modula-2',
as it appeared in [1],
from now on referred to as 'the Report'.
Also,
the Report sometimes leaves room for interpretation.
The section numbers
mentioned are the section numbers of the Report.
.SH
Syntax (section 2)
.PP
The syntax recognized is that of the Report,
with some extensions to
also recognize the syntax of an earlier definition,
given in [2].
Only one compilation unit per file is accepted.
.SH
Vocabulary and Representation (section 3)
.PP
The input '\f(CW10..\fR' is parsed as two tokens: '\f(CW10\fR' and '\f(CW..\fR'.
.PP
The empty string \f(CW""\fR has type
.DS
.ft CW
ARRAY [0 .. 0] OF CHAR
.ft P
.DE
and contains one character: \f(CW0C\fR.
.PP
When the text of a comment starts with a '\f(CW$\fR',
it may be a pragma.
Currently,
the following pragmas exist:
.nf
.sp \\n(PDu
.ft CW
(*$F      (F stands for Foreign) *)
(*$R[+|-] (Runtime checks, on or off, default on) *)
(*$A[+|-] (Array bound checks, on or off, default off) *)
(*$U      (Allow for underscores within identifiers) *)
.ft P
.sp \\n(PDu
.fi
The Foreign pragma is only meaningful in a \f(CWDEFINITION MODULE\fR,
and indicates that this
\f(CWDEFINITION MODULE\fR describes an interface to a module written in another
language (for instance C or Pascal).
Runtime checks that can be disabled are:
range checks,
\f(CWCARDINAL\fR overflow checks,
checks when assigning a \f(CWCARDINAL\fR to an \f(CWINTEGER\fR and vice versa,
and checks that \f(CWFOR\fR-loop control-variables are not changed
in the body of the loop.
Array bound checks can be enabled,
because many EM implementations do not
implement the array bound checking of the EM array instructions.
When enabled,
the compiler generates a check before generating an
EM array instruction.
Even when underscores are enabled,
they still may not start an identifier.
.PP
Constants of type \f(CWLONGINT\fR are integers with a suffix letter \f(CWD\fR
(for instance \f(CW1987D\fR).
Constants of type \f(CWLONGREAL\fR have suffix \f(CWD\fR if a scale factor is missing,
or have \f(CWD\fR in place of \f(CWE\fR in the scale factor (f.i. \f(CW1.0D\fR,
\f(CW0.314D1\fR).
This addition was made,
because there was no way to indicate long constants,
and also because the addition was made in Wirth's newest Modula-2 compiler.
.SH
Declarations and scope rules (section 4)
.PP
Standard identifiers are predeclared,
and valid in all
parts of a program.
They are called \fIpervasive\fR.
Unfortunately,
the Report does not state how this pervasiveness is accomplished.
However,
page 87 of [1] states: 'Standard identifiers are automatically
imported into all modules'.
Our implementation therefore allows
redeclarations of standard identifiers within procedures,
but not within
modules.
.SH
Constant expressions (section 5)
.PP
Each operand of a constant expression must be a constant:
a string,
a number,
a set,
an enumeration literal,
a qualifier denoting a
constant expression,
a type transfer with a constant argument,
or one of the standard procedures
\f(CWABS\fR,
\f(CWCAP\fR,
\f(CWCHR\fR,
\f(CWLONG\fR,
\f(CWMAX\fR,
\f(CWMIN\fR,
\f(CWODD\fR,
\f(CWORD\fR,
\f(CWSIZE\fR,
\f(CWSHORT\fR,
\f(CWTSIZE\fR,
or \f(CWVAL\fR,
with constant argument(s);
\f(CWTSIZE\fR and \f(CWSIZE\fR may also have a variable as argument.
.SH
Type declarations (section 6)
.LP
.I
1. Basic types (section 6.1)
.PP
The type \f(CWCHAR\fR includes the ASCII character set as a subset.
Values range from
\f(CW0C\fR to \f(CW377C\fR,
not from \f(CW0C\fR to \f(CW177C\fR.
.LP
.I
2. Enumerations (section 6.2)
.PP
The maximum number of enumeration literals in any one enumeration type
is \f(CWMAX(INTEGER)\fR.
.LP
.I
3. Record types (section 6.5)
.PP
The syntax of variant sections in [1] is different from the one in [2].
Our implementation recognizes both,
giving a warning for the older one.
.LP
.I
4. Set types (section 6.6)
.PP
The only limitation imposed by the compiler is that the base type of the
set must be a subrange type,
an enumeration type,
\f(CWCHAR\fR,
or \f(CWBOOLEAN\fR.
So,
the lower bound may be negative.
However,
if a negative lower bound is used,
the compiler gives a warning of the \fIrestricted\fR class.
.PP
The standard type \f(CWBITSET\fR is defined as
.DS
.ft CW
TYPE BITSET = SET OF [0 .. 8*SIZE(INTEGER)-1];
.ft P
.DE
.SH
Expressions (section 8)
.LP
.I
1. Operators (section 8.2)
.LP
.I
1.1. Arithmetic operators (section 8.2.1)
.PP
The Report does not specify the priority of the unary
operators \f(CW+\fR or \f(CW-\fR:
It does not specify whether
.DS
.ft CW
- 1 + 1
.ft P
.DE
means
.DS
.ft CW
- (1 + 1)
.ft P
.DE
or
.DS
.ft CW
(-1) + 1
.ft P
.DE
The
.MX
Modula-2 compiler implements the second alternative.
.SH
Statements (section 9)
.LP
.I
1. Assignments (section 9.1)
.PP
The Report does not define the evaluation order in an assignment.
Our compiler certainly chooses an evaluation order,
but it is explicitly left undefined.
Therefore,
programs that depend on it may cease to work later.
.PP
The types \f(CWINTEGER\fR and \f(CWCARDINAL\fR are assignment-compatible with
\f(CWLONGINT\fR,
and \f(CWREAL\fR is assignment-compatible with \f(CWLONGREAL\fR.
.LP
.I
2. Case statements (section 9.5)
.PP
The size of the type of the case-expression must be less than or equal to
the word-size.
.PP
The Report does not specify what happens if the value of the case-expression
does not occur as a label of any case,
and there is no \f(CWELSE\fR-part.
In our implementation,
this results in a runtime error.
.LP
.I
3. For statements (section 9.8)
.PP
The Report does not specify the legal types for a control variable.
Our implementation allows the basic types (except \f(CWREAL\fR),
enumeration types,
and subranges.
A runtime warning is generated when the value of the control variable
is changed by the statement sequence that forms the body of the loop,
unless runtime checking is disabled.
.LP
.I
4. Return and exit statements (section 9.11)
.PP
The Report does not specify which result-types are legal.
Our implementation allows any result type.
.SH
Procedure declarations (section 10)
.PP
Function procedures must exit through a RETURN statement,
or a runtime error occurs.
.LP
.I
1. Standard procedures (section 10.2)
.PP
Our implementation supports \f(CWNEW\fR and \f(CWDISPOSE\fR
for backwards compatibility,
but issues warnings for their use.
.PP
Also,
some new standard procedures were added,
similar to the new standard procedures in Wirth's newest compiler:
.IP \-
\f(CWLONG\fR converts an argument of type \f(CWINTEGER\fR or \f(CWREAL\fR to the
types \f(CWLONGINT\fR or \f(CWLONGREAL\fR.
.IP \-
\f(CWSHORT\fR performs the inverse transformation,
without range checks.
.IP \-
\f(CWFLOATD\fR is analogous to \f(CWFLOAT\fR,
but yields a result of type
\f(CWLONGREAL\fR.
.IP \-
\f(CWTRUNCD\fR is analogous to \f(CWTRUNC\fR,
but yields a result of type
\f(CWLONGINT\fR.
.SH
System-dependent facilities (section 12)
.PP
The type \f(CWBYTE\fR is added to the \f(CWSYSTEM\fR module.
It occupies a storage unit of 8 bits.
\f(CWARRAY OF BYTE\fR has a similar effect to \f(CWARRAY OF WORD\fR,
but is safer.
In some obscure cases the \f(CWARRAY OF WORD\fR mechanism does not quite
work properly.
.PP
The procedure \f(CWIOTRANSFER\fR is not implemented.
.SH
Backwards compatibility
.PP
Besides recognizing the language as described in [1],
the compiler recognizes most of the language described in [2],
for backwards compatibility.
It warns the user for old-fashioned
constructions (constructions that [1] does not allow).
If the \fI\(en3\fR option is passed to \fIm2\fR,
this backwards compatibility feature is disabled.
.SH
Compile time errors
.PP
The compile time error messages are intended to be self-explanatory,
and not listed here.
The compiler also sometimes issues warnings,
recognizable by a warning-classification between parentheses.
There are 3 classifications:
.IP "(old-fashioned use)"
.br
These warnings are given on constructions that are not allowed by [1],
but are allowed by [2].
.IP (strict)
.br
These warnings are given on constructions that are supported by the
.MX
Modula-2 compiler,
but might not be supported by others.
Examples: functions returning structured types,
SET types of subranges with
negative lower bound.
.IP (warning)
.br
The other warnings,
such as warnings about variables that are never assigned,
never used,
etc.
.SH
Runtime errors
.PP
The \fITraps\fR module enables the user to install his own runtime
error handler.
The default one just displays what happened and exits.
Basically,
a trap handler is just a procedure that takes an INTEGER as
parameter.
The INTEGER is the trap number.
This INTEGER can be one of the
EM trap numbers,
listed in [3],
or one of the numbers listed in the
\fITraps\fR definition module.
.PP
The following runtime errors may occur:
.IP "array bound error"
.br
This error is detected if the \fI\(enA\fR option is given to \fIm2\fR.
.IP "range bound error"
.br
Range bound errors are always detected,
unless runtime checks are disabled.
.IP "set bound error"
.IP "cardinal overflow"
.br
This error is detected,
unless runtime checks are disabled.
.IP "cardinal underflow"
.br
This error is detected,
unless runtime checks are disabled.
.IP "divide by 0"
.IP "divide by 0.0"
.IP "conversion error"
.br
This error occurs when assigning a negative value of type INTEGER to a
variable of type CARDINAL,
or when assigning a value of CARDINAL that is > MAX(INTEGER),
to a variable of type INTEGER.
It is detected,
unless runtime checking is disabled.
.IP "heap overflow"
.br
This might happen when ALLOCATE fails.
.IP "case error"
.br
This error occurs when non of the cases in a CASE statement are selected,
and the CASE statement has no ELSE part.
.IP "stack size of process too large"
.br
This is most likely to happen if the reserved space for a coroutine stack
is too small.
In this case,
increase the size of the area given to
\f(CWNEWPROCESS\fR.
It can also happen if the stack needed for the main
process is too large and there are coroutines.
In this case,
the only fix is to reduce the stack size needed by the main process,
f.i. by avoiding local arrays.
.IP "too many nested traps + handlers"
.br
This error can only occur when the user has installed his own trap handler.
It means that during execution of the trap handler another trap has occurred,
and that several times.
In some cases,
this is an error because of overflow of some internal tables.
.IP "no RETURN from function procedure"
.br
This error occurs when a function procedure does not return properly
('falls' through).
.IP "illegal instruction"
.br
This error might occur when you use floating point operations on an
implementation that does not have floating point.
.PP
In addition,
some of the library modules may give error messages.
The \fBTraps\fR-module has a suitable mechanism for this.
.SH
The procedure call interface
.PP
Parameters are pushed on the stack in reversed order.
For VAR parameters,
its address is passed,
for value parameters its value.
The only exception to this rule is with conformant arrays.
For conformant arrays,
the address is passed,
and an array descriptor is
passed.
The descriptor is an EM array descriptor.
It consists of three
fields: the lower bound (always 0),
upper bound \(mi lower bound,
and the size of the elements.
The descriptor is pushed first.
If the parameter is a value parameter,
the called routine must make sure
that its value is never changed,
for instance by making its own copy
of the array.
.PP
When the size of the return value of a function procedure is larger than
the maximum of \f(CWSIZE(LONGREAL)\fR and twice the pointer-size,
the caller reserves this space on the stack,
above the parameters.
Callee then stores
its result there,
and returns no other value.
.SH
Makefile generator
.PP
The compiler itself has no version checking mechanism.
A special linker
would be needed to do that.
Therefore,
a makefile generator is included (\fIm2mm\fR).
.SH
The Modula-2 runtime library
.PP
The definition modules of the modules available in the
.MX
Modula-2 runtime library reside in the directory \fI/usr/lib/m2\fR.
.SH
References
.IP [1]
Niklaus Wirth,
.I
Programming in Modula-2, third, corrected edition,
.R
Springer-Verlag, Berlin (1985)
.IP [2]
Niklaus Wirth,
.I
Programming in Modula-2,
.R
Stringer-Verlag, Berlin (1983)
.IP [3]
A.S.Tanenbaum, J.W.Stevenson, Hans van Staveren, E.G.Keizer,
.I
Description of a machine architecture for use with block structured languages,
.R
Informatica rapport IR-81, Vrije Universiteit, Amsterdam
.NH 1
THE MINIX PASCAL COMPILER
.PP
.de IT
.br
.ne 3
.sp \\n(PDu
.in 0
\\fBBS~\\$1:\\fR~\\
..
.de IS
.ne 2
.sp \\n(PDu
.in +3
..
.PP
This section refers to the (1982) BSI standard for Pascal [1].
.MX
Pascal complies with the requirements of level 1 of BS 6192: 1982, with
the exceptions as listed in this section.
.PP
The standard requires an accompanying document describing the
implementation-defined and implementation-dependent features,
the reaction on errors and the extensions to standard Pascal.
These four items will be treated in the rest of this section.
.SH 
Implementation-defined features
.PP
For each implementation-defined feature mentioned in the BSI standard
we give the section number, the quotation from that section and the definition.
First we quote the definition of implementation-defined:
.DS
Possibly differing between processors, but defined for any particular
processor.
.DE
.IT 6.1.7
Each string-character shall denote an implementation-defined value of the
required char-type.
.IS
All 7-bit ASCII characters except linefeed LF (10) are allowed.
.IT 6.4.2.2
The values of type real shall be an implementation-defined subset
of the real numbers denoted as specified by 6.1.5 by the signed-real values.
.IS
The set of real values range from a low of \(mi1.7976931348623157e+308 to
a high of 1.7976931348623157e+308.
.IT 6.4.2.2
The type char shall be the enumeration of a set of implementation-defined
characters, some possibly without graphic representations.
.IS
The 7-bit ASCII character set is used, where LF (10) denotes the
end-of-line marker on text-files.
.IT 6.4.2.2
The ordinal numbers of the character values shall be values of integer-type,
that are implementation-defined, and that are determined by mapping
the character values on to consecutive non-negative integer values
starting at zero.
.IS
The normal ASCII ordering is used: ord('0')=48, ord('A')=65, ord('a')=97, etc.
.IT 6.6.5.2
The post-assertions imply corresponding activities on the external entities,
if any, to which the file-variables are bound.
These activities, and the
point at which they are actually performed, shall be
implementation-defined.
.IS
The reading and writing writing of objects on files is buffered.
This means that when a program terminates abnormally, I/O may be
unfinished.
Terminal I/O is unbuffered.
Files are closed whenever they are rewritten or reset, or on
program termination.
.IT 6.7.2.2
The predefined constant \fImaxint\fR shall be of integer-type and shall denote
an implementation-defined value, that satisfies the following conditions:
.IP (a) 2m
All integral values in the closed interval from \fI\(mimaxint\fR to \fI+maxint\fR
shall be values of the integer-type.
.IP (b) 2m
Any monadic operation performed on an integer value in this interval
shall be correctly performed according to the mathematical rules for
integer arithmetic.
.IP (c) 2m
Any dyadic integer operation on two integer values in this same interval
shall be correctly performed according to the mathematical rules for
integer arithmetic, provided that the result is also in this interval.
.IP (d) 2m
Any relational operation on two integer values in this same interval
shall be correctly performed according to the mathematical rules for
integer arithmetic.
.LP
.in +3
The representation of integers is a 16-bit word using
two's complement arithmetic.
The integers range from \(mi32768 to +32767.
.IT 6.7.2.2
The result of the real arithmetic operators and functions shall be
approximations to the corresponding mathematical results.
The accuracy of
this approximation shall be implementation-defined
.IS
The default size of reals is 8 bytes, the accuracy is 11 bits for the exponent,
and 53 bits for the mantissa.
This gives an accuracy of about 16 digits.
and exponents ranging from \(mi307 to +307.
.IT 6.9.3.1
The default TotalWidth values for integer, Boolean and real types
shall be implementation-defined.
.IS
The defaults are:
.TS
l r.
integer	6
Boolean	5
real	14
.TE
.IT 6.9.3.4.1
ExpDigits, the number of digits written in an exponent part of a real,
shall be implementation-defined.
.IS
ExpDigits is defined as 3.
.IT 6.9.3.4.1
The character written as part of the representation of
a real to indicate the beginning of the exponent part shall be
implementation-defined, either 'E' or 'e'.
.IS
The exponent part starts with 'e'.
.IT 6.9.3.5
The case of the characters written as representation of the
Boolean values shall be implementation-defined.
.IS
The representations of true and false are 'true' and 'false'.
.IT 6.9.5
The effect caused by the standard procedure page
on a text file shall be implementation-defined.
.IS
The ASCII character form feed FF (12) is written.
.IT 6.10
The binding of the variables denoted by the program-parameters
to entities external to the program shall be implementation-defined if
the variable is of a file-type.
.IS
The program parameters must be files and all, except input and output,
must be declared as such in the program block.
.PP
The program parameters input and output, if specified, will correspond
with the UNIX streams 'standard input' and 'standard output'.
.PP
The other program parameters will be mapped to the argument strings
provided by the caller of this program.
The argument strings are supposed to be path names of the files to be
opened or created.
The order of the program parameters determines the mapping:
the first parameter is mapped onto the first argument string etc.
Note that input and output are ignored in this mapping.
.PP
The mapping is recalculated each time a program parameter
is opened for reading or writing by a call to the standard procedures
reset or rewrite.
This gives the programmer the opportunity to manipulate the list
of string arguments using the external procedures argc, argv and argshift
available in \fIlibp.A\fR.
.IT 6.10
The effect of an explicit use of reset or rewrite
on the standard text files input or output shall be implementation-defined.
.IS
The procedures reset and rewrite are no-ops
if applied to input or output.
.in 0
.SH 
Implementation-dependent features
.PP
For each implementation-dependent feature mentioned in the BSI standard,
we give the section number, the quotation from that section and the way
this feature is treated by the 
.MX
Pascal system.
First we quote the definition of 'implementation-dependent':
.DS
Possibly differing between processors and not necessarily defined for any
particular processor.
.DE
.IT 6.7.2.1
The order of evaluation of the operands of a dyadic operator
shall be implementation-dependent.
.IS
Operands are always evaluated, so the program part
.DS
if (p<>nil) and (p^.value<>0) then
.DE
is probably incorrect.
.PP
The left-hand operand of a dyadic operator is almost always evaluated
before the right-hand side.
Some peculiar evaluations exist for the following cases:
.IP 1.
The modulo operation is performed by a library routine to
check for negative values of the right operand.
.IP 2.
The expression
.DS
set1 <= set2
.DE
where set1 and set2 are compatible set types is evaluated in the
following steps:
.DS
-~~~evaluate set2;
-~~~evaluate set1;
-~~~compute set2+set1;
-~~~test set2 and set2+set1 for equality.
.DE
.IP 3.
The expression
.DS
set1 >= set2
.DE
where set1 and set2 are compatible set types is evaluated in the following steps:
.DS
-~~~evaluate set1;
-~~~evaluate set2;
-~~~compute set1+set2;
-~~~test set1 and set1+set2 for equality.
.DE
.IT 6.7.3
The order of evaluation, accessing and binding
of the actual-parameters for functions
shall be implementation-dependent.
.IS
The order of evaluation is from right to left.
.IT 6.8.2.2
The decision as to the order of accessing the variable and evaluating
the expression in an assignment-statement, shall be
implementation-dependent.
.IS
The expression is evaluated first.
.IT 6.8.2.3
The order of evaluation and binding of the actual-parameters for procedures
shall be implementation-dependent.
.IS
The same as for functions.
.IT 6.9.5
The effect of inspecting a text file to which the page
procedure was applied during generation is
implementation-dependent.
.IS
The formfeed character written by page is
treated like a normal character, with ordinal value 12.
.IT 6.10
The binding of the variables denoted by the program-parameters
to entities external to the program shall be implementation-dependent unless
the variable is of a file-type.
.IS
Only variables of a file-type are allowed as program parameters.
.in 0
.SH 
Error handling
.PP
There are three classes of errors to be distinguished.
In the first class are the error messages generated by the compiler.
The second class consists of the occasional errors generated by the other
programs involved in the compilation process.
Errors of the third class are the errors as defined in the standard by:
.DS
An error is a violation by a program of the requirements of this standard
that a processor is permitted to leave undetected.
.DE
.LP
.I
Compiler errors
.PP
Error are written on the standard error output.
Each line has the form:
.DS
<file>, line <number>: <description>
.DE
Every time the compiler detects an error that does not have influence
on the code produced by the compiler or on the syntax decisions, a warning
messages is given.
If only warnings are generated, compilation proceeds and probably results
in a correctly compiled program.
.PP
Sometimes the compiler produces several errors for the same line.
They are only shown up to a maximum of 5 errors per line.
Warning are also shown up to a maximum of 5 per line.
.PP
Extensive treatment of these errors is outside the scope of this manual.
.LP
.I
Runtime errors
.PP
Errors detected at run time cause an error message to be generated on the
diagnostic output stream (UNIX file descriptor 2).
The message consists of the name of the program followed by a message
describing the error, possibly followed by the source line number.
Unless the \fI\(enn\fR option is turned on, the compiler generates code to keep track
of which source line causes which instructions to be generated.
.PP
For each error mentioned in the standard we give the section number,
the quotation from that section and the way it is processed by the
Pascal-compiler or runtime system.
.PP
For detected errors the corresponding message
and trap number are given.
Trap numbers are useful for exception-handling routines.
Normally, each error causes the program to terminate.
By using exception-handling routines one can
ignore errors or perform alternate actions.
Only some of the errors can be ignored
by restarting the failing instruction.
These errors are marked as non-fatal,
all others as fatal.
A list of errors with trap number between 0 and 63
(EM errors) can be found in [2].
Errors with trap number between 64 and 127 (Pascal errors) are listed below.
.IT 6.4.6
It shall be an error if a value of type T2 must be
assignment-compatible with type T1, while
T1 and T2 are compatible ordinal-types and the value of
type T2 is not in the closed interval specified by T1.
.IS
The compiler distinguishes between array-index expressions and the other
places where assignment-compatibility is required.
.PP
Array subscripting errors are only detected when the 'A' option is used.
In the other cases, a range bound error occurs when the value of type T2
is not in the closed interval specified by T1, unless range checks are
disabled.
.IT 6.4.6
It shall be an error if a value of type T2 must be
assignment-compatible with type T1, while T1 and T2 are compatible
set-types and any member of the value of type T2
is not in the closed interval specified by the base-type
of the type T1.
.IS
This error is not detected.
.IT 6.5.3.3
It shall be an error if a component of a variant-part of a variant,
where the selector of the variant-part is not a field,
is accessed unless the variant is active for the entirety of each
reference and access to each component of the variant.
.IS
This error is not detected.
.IT 6.5.4
It shall be an error if
the pointer-variable of an identified-variable either denotes a
nil-value or is undefined.
.IS
This error is not detected.
.IT 6.5.4
It shall be an error to remove the identifying-value of an identified
variable from its pointer-type when a reference to the variable exists.
.IS
When the identified variable is an element of the record-variable-list of
a with-statement, a warning is given at compile-time.
Otherwise, this error is not detected.
.IT 6.5.5
It shall be an error to alter the value of a file-variable f when a
reference to the buffer-variable f^ exists.
.IS
When f is altered when it is an element of the record-variable-list of a
with-statement, a warning is given.
When a buffer-variable is used as a
variable-parameter, an error is given.
This is done at compile-time.
.IT 6.6.5.2
It shall be an error if
the stated pre-assertion does not hold immediately
prior to any use of the file handling procedures
rewrite, put, reset and get.
.IS
For each of these four operations the pre-assertions
can be reformulated as:
.sp \n(PDu
.TS
l l.
rewrite(f):	no pre-assertion.
put(f):	f is opened for writing and f^ is not undefined.
reset(f):	f exists.
get(f):	f is opened for reading and eof(f) is false.
.TE
.sp \n(PDu
The following errors are detected for these operations:
.sp \n(PDu
rewrite(f):
.in +6
.ti -3
more args expected, trap 64, fatal:
.br
f is a program-parameter and the corresponding
file name is not supplied by the caller of the program.
.ti -3
rewrite error, trap 101, fatal:
.br
the caller of the program lacks the necessary
access rights to create the file in the file system
or operating system problems like table overflow
prevent creation of the file.
.in -6
.sp \n(PDu
put(f):
.in +6
.ti -3
file not yet open, trap 72, fatal:
.br
reset or rewrite are never applied to the file.
The checks performed by the run time system are not foolproof.
.ti -3
not writable, trap 96, fatal:
.br
f is opened for reading.
.ti -3
write error, trap 104, fatal:
.br
probably caused by file system problems.
For instance, the file storage is exhausted.
Because I/O is buffered to improve performance,
it might happen that this error occurs if the
file is closed.
Files are closed whenever they are rewritten or reset, or on
program termination.
.in -6
.sp \n(PDu
reset(f):
.in +6
.ti -3
more args expected, trap 64, fatal:
.br
same as for rewrite(f).
.ti -3
reset error, trap 100, fatal:
.br
f does not exist, or the caller has insufficient access rights, or
operating system tables are exhausted.
.in -6
.sp \n(PDu
get(f):
.in +6
.ti -3
file not yet open, trap 72, fatal:
.br
as for put(f).
.ti -3
not readable, trap 97, fatal:
.br
f is opened for writing.
.ti -3
end of file, trap 98, fatal:
.br
eof(f) is true just before the call to get(f).
.ti -3
read error, trap 103, fatal:
.br
unlikely to happen.
Probably caused by hardware problems
or by errors elsewhere in your program that destroyed
the file information maintained by the run time system.
.ti -3
truncated, trap 99, fatal:
.br
the file is not properly formed by an integer
number of file elements.
For instance, the size of a file of integer is odd.
.ti -3
non-ASCII char read, trap 106, non-fatal:
.br
the character value of the next character-type
file element is out of range (0..127).
Only for text files.
.in -6
.IT 6.6.5.3
It shall be an error if a variant of a variant-part within the new
variable becomes active and a different variant of the variant-part is
one of the specified variants.
.IS
This error is not detected.
.IT 6.6.5.3
It shall be an error to use dispose(q) if the identifying variable has been
allocated using the form new(p,c1,...,cn).
.IS
This error is not detected.
However, this error can cause more memory
to be freed then was allocated.
Dispose causes a fatal trap 73 when memory already on the free
list is freed again.
.IT 6.6.5.3
It shall be an error to use dispose(q,k1,...,km) if the identifying
variable has been allocated using the form new(p,c1,...,cn) and m is not
equal to n.
.IS
This error is not detected.
However, this error can cause more memory
to be freed then was allocated.
Dispose causes a fatal trap 73 when memory already on the free
list is freed again.
.IT 6.6.5.3
It shall be an error if the variants of a variable to be disposed
are different from those specified by the case-constants to dispose.
.IS
This error is not detected.
.IT 6.6.5.3
It shall be an error if the value of the pointer parameter of dispose has
nil-value or is undefined.
.IS
This error is detected for nil-value (dispose error, trap 73, fatal).
.IT 6.6.5.3
It shall be an error if a variable created using the second form of new is
accessed by the identified variable of the variable-access of a factor,
of an assignment-statement, or of an actual-parameter.
.IS
This error is not detected.
.IT 6.6.6.2
It shall be an error if the value of sqr(x) does not exist.
.IS
This error is detected for real-type arguments (real overflow,
trap 4, non-fatal).
.IT 6.6.6.2
It shall be an error if x in ln(x) is smaller than or equal to 0.
.IS
This error is detected (error in ln, trap 66, non-fatal)
.IT 6.6.6.2
It shall be an error if x in sqrt(x) is smaller than 0.
.IS
This error is detected (error in sqrt, trap 67, non-fatal)
.sp \n(PDu
In addition to these errors, overflow in the expression exp(x) is
detected (error in exp, trap 65, non-fatal; real overflow, trap 4, non-fatal)
.IT 6.6.6.3
It shall be an error if
the integer value of trunc(x) does not exist.
.IS
This error is detected (conversion error, trap 10, non-fatal).
.IT 6.6.6.3
It shall be an error if
the integer value of round(x) does not exist.
.IS
This error is detected (conversion error, trap 10, non-fatal).
.IT 6.6.6.4
It shall be an error if
the integer value of ord(x) does not exist.
.IS
This error can not occur, because the compiler will not allow
such ordinal types.
.IT 6.6.6.4
It shall be an error if
the character value of chr(x) does not exist.
.IS
This error is detected (range bound error, trap 1, non-fatal).
.IT 6.6.6.4
It shall be an error if the value of succ(x) does not exist.
.IS
Same comments as for chr(x).
.IT 6.6.6.4
It shall be an error if the value of pred(x) does not exist.
.IS
Same comments as for chr(x).
.IT 6.6.6.5
It shall be an error if f in eof(f) is undefined.
.IS
This error is detected (file not yet open, trap 72, fatal).
.IT 6.6.6.5
It shall be an error if
f in eoln(f) is undefined, or if eof(f) is true at that time.
.IS
The following errors may occur:
.IS
file not yet open, trap 72, fatal;
.br
not readable, trap 97, fatal;
.br
end of file, trap 98, fatal.
.IT 6.7.1
It shall be an error if a variable-access used as an operand
in an expression is undefined at the time of its use.
.IS
The compiler performs some limited checks to see if identifiers are
used before they are set.
Since it can not always be sure (one could, for
instance, jump out of a loop), only a warning is generated.
When an
expression contains a function-call, an error occurs if the
function is not assigned at run-time.
.IT 6.7.2.2
A term of the form x/y shall be an error if y is zero.
.IS
This error is detected (divide by 0.0, trap 7, non-fatal).
.IT 6.7.2.2
It shall be an error if j is zero in 'i div j'.
.IS
This error is detected (divide by 0, trap 6, non-fatal).
.IT 6.7.2.2
It shall be an error if
j is zero or negative in i MOD j.
.IS
This error is detected (only positive j in 'i mod j', trap 71, non-fatal).
.IT 6.7.2.2
It shall be an error if the result of any operation on integer
operands is not performed according to the mathematical
rules for integer arithmetic.
.IS
This implementation does not detect integer overflow.
.IT 6.8.3.5
It shall be an error if none of the case-constants is equal to the
value of the case-index upon entry to the case-statement.
.IS
This error is detected (case error, trap 20, fatal).
.IT 6.9.1
It shall be an error if the sequence of characters read looking for an
integer does not form a signed-integer as specified in 6.1.5.
.IS
This error is detected (digit expected, trap 105, non-fatal).
.IT 6.9.1
It shall be an error if the sequence of characters read looking for a
real does not form a signed-number as specified in 6.1.5.
.IS
This error is detected (digit expected, trap 105, non-fatal).
.IT 6.9.1
When read is applied to f, it shall be an error if the buffer-variable f^
is undefined or the pre-assertions for get do not hold.
.IS
This error is detected (see get(f)).
.IT 6.9.3
When write is applied to a text file f, it shall be an error if f is
undefined or f is opened for reading.
.IS
This error is detected (see put(f)).
Furthermore, this error is also
detected when f is not a text file.
.IT 6.9.3.1
The values of TotalWidth or FracDigits shall be greater than or equal to
one; it shall be an error if either value is less then one.
.IS
When either value is less than zero, an error (illegal field width, trap
75, non-fatal) occurs.
Zero values are allowed, in order to maintain some
compatibility with the old 
.MX
Pascal compiler.
.IT 6.9.5
It shall be an error if the pre-assertion required for writeln(f) doe not
hold prior to the invocation of page(f);
.IS
This error is detected (see put(f)).
.in 0
.SH 
Extensions to the standard
.LP
.I
1. External routines
.LP
Except for the required directive 'forward' the 
.MX
Pascal compiler recognizes
the directive 'extern'.
This directive tells the compiler that the procedure block of this
procedure will not be present in the current program.
The code for the body of this procedure must be included at a later
stage of the compilation process.
.PP
This feature allows one to build libraries containing often used routines.
These routines do not have to be included in all the programs using them.
Maintenance is much simpler if there is only one library module to be
changed instead of many Pascal programs.
.PP
Another advantage is that these library modules may be written in a different
language, for instance C.
.PP
The use of external routines, however, is dangerous.
The compiler normally checks for the correct number and type of parameters
when a procedure is called and for the result type of functions.
If an external routine is called these checks are not sufficient,
because the compiler can not check whether the procedure heading of the
external routine as given in the Pascal program matches the actual routine
implementation.
It should be the loader's task to check this.
However, the current loaders are not that smart.
.PP
For those who wish the use the interface between C and Pascal we
give an incomplete list of corresponding formal parameters in C and Pascal.
.sp \n(PDu
.TS
l l.
Pascal	C
a:integer	int a
a:char	int a
a:boolean	int a
a:real	double a
a:^type	type *a
var a:type	type *a
procedure a(pars)	struct {
	     void (*a)() ;
	     char *static_link ;
	}
function a(pars):type	struct {
	     type (*a)() ;
	     char *static_link ;
	}
.TE
The Pascal runtime system uses the following algorithm when calling
function/procedures passed as parameters.
.TS
l l.
if ( static_link )	(*a)(static_link,pars) ;
else	(*a)(pars) ;
.TE
.LP
.I
2. Separate compilation.
.LP
The compiler is able to (separately) compile a collection of declarations,
procedures and functions to form a library.
The library may be linked with the main program, compiled later.
The syntax of these modules is
.DS
module = \kx[constant-definition-part]
\h'|\nxu'[type-definition-part]
\h'|\nxu'[var-declaration-part]
\h'|\nxu'[procedure-and-function-declaration-part]
.DE
The compiler accepts a program or a module:
.DS
unit = program | module
.DE
All variables declared outside a module must be imported
by parameters, even the files input and output.
Access to a variable declared in a module is only possible
using the procedures and functions declared in that same module.
By giving the correct procedure/function heading followed by the
directive 'extern' you may use procedures and functions declared in
other units.
.LP
.I
3. Assertions.
.LP
When the s-option is off, 
.MX
Pascal compiler recognizes an additional
statement, the assertion.
Assertions can be used as an aid in debugging
and documentation.
The syntax is:
.DS
assertion = 'assert' Boolean-expression
.DE
An assertion is a simple-statement, so
.DS
simple-statement = \kx[assignment-statement |
\h'|\nxu' procedure-statement |
\h'|\nxu' goto-statement |
\h'|\nxu' assertion
\h'|\nxu']
.DE
An assertion causes an error if the Boolean-expression is false.
That is its only purpose.
It does not change any of the variables, at least it should not.
Therefore, do not use functions with side-effects in the Boolean-expression.
If the a-option is turned on, then assertions are skipped by the
compiler. 'assert' is not a word-symbol (keyword) and may be used as identifier.
However, assignment to a variable and calling of a procedure with that
name will be impossible.
If the s-option is turned on, the compiler will not know a thing about
assertions, so using assertions will then give a parse error.
.LP
.I
4. Additional procedures.
.LP
Three additional standard procedures are available:
.IP "" 3m
.RS
.IP "halt:" 3m
a call of this procedure is equivalent to jumping to the
end of your program.
It is always the last statement executed.
The exit status of the program may be supplied
as optional argument.
If not, it will be zero.
.IP release: 3m
.IP mark: 3m
for most applications it is sufficient to use the heap as second stack.
Mark and release are suited for this type of use, more suited than dispose.
mark(p), with p of type pointer, stores the current value of the
heap pointer in p. release(p), with p initialized by a call
of mark(p), restores the heap pointer to its old value.
All the heap objects, created by calls of new between the call of
mark and the call of release, are removed and the space they used
can be reallocated.
Never use mark and release together with dispose!
.RE
.LP
.I
5. UNIX interfacing.
.LP
If the c-option is turned on, then some special features are available
to simplify an interface with the UNIX environment.
First of all, the compiler allows you to use a different type
of string constants.
These string constants are delimited by double quotes ('"').
To put a double quote into these strings, you must repeat the double quote,
like the single quote in normal string constants.
These special string constants are terminated by a zero byte (chr(0)).
The type of these constants is a pointer to a packed array of characters,
with lower bound 1 and unknown upper bound.
.br
Secondly, the compiler predefines a new type identifier 'string' denoting
this just described string type.
.PP
The only thing you can do with these features is declaration of
constants and variables of type 'string'.
String objects may not be allocated on the heap and string pointers
may not be de-referenced.
Still these strings are very useful in combination with external routines.
The procedure write is extended to print these zero-terminated
strings correctly.
.LP
.I
6. Double length (32 bit) integers.
.LP
If the d-option is turned on, then the additional type 'long' is known
to the compiler.
Long variables have integer values in the
range \(mi2147483648 .. +2147483647.
Long constants can not be declared.
Longs can not be used as control-variables.
It is not allowed to form subranges of type long.
All operations allowed on integers are also
allowed on longs and are indicated by the same
operators: '+', '-', '*', '/', 'div', 'mod'.
The procedures read and write have been extended to handle long
arguments correctly.
It is possible to read longs from a file of integers
and vice-versa, but only if longs and integers have the same size.
The default width for longs is 11.
The standard procedures 'abs' and 'sqr' have been extended to work
on long arguments.
Conversion from integer to long, long to real,
real to long and long to integer are automatic, like the conversion
from integer to real.
These conversions may cause a
.IS
conversion error, trap 10, non-fatal
.in 0
.LP
.I
7. Underscore as letter.
.LP
The character '_' may be used in forming identifiers, if the u- or U-option
is turned on.
It is forbidden to start identifiers with underscores, since
this may cause name-clashes with run-time routines.
.LP
.I
8. Zero field width in write.
.LP
Zero TotalWidth arguments are allowed.
In this case, no characters are written for
character, string or Boolean type arguments.
A zero FracDigits
argument for fixed-point representation of reals causes the fraction and
the character '.' to be suppressed.
.LP
.I
9. Pre-processing.
.LP
If the very first character of a file containing a Pascal
program is the sharp ('#', ASCII 23(hex)) the file is preprocessed
in the same way as C programs.
Lines beginning with a '#' are taken as preprocessor command lines
and not fed to the Pascal compiler proper.
C style comments, /*......*/, are removed by the C preprocessor,
thus C comments inside Pascal programs are also removed when they
are fed through the preprocessor.
.in 0
.SH 
Deviations from the standard
.PP
.MX
Pascal deviates from the standard in the following ways:
.IP 1. 3m
Standard procedures and functions are not allowed as parameters in 
.MX
Pascal.
You can obtain the same result with negligible loss of performance
by declaring some user routines like:
.DS
.ft CW
function sine(x:real):real;
begin
    sine:=sin(x)
end;
.ft R
.DE
.IP 2. 3m
The standard procedures read, readln, write and writeln are implemented as
word-symbols, and can therefore not be redeclared.
.SH 
Compiler options
.PP
Some options of the compiler may be controlled by using '{$....}'.
Each option consists of a lower case letter followed by +, \(mi or an unsigned
number.
Options are separated by commas.
The following options exist:
.IP a~+/\(mi 3m
This option switches assertions on and off.
If this option is on, then code is included to test these assertions
at run time.
Default +.
.IP c~+/\(mi 3m
This option, if on, allows you to use C-type string constants
surrounded by double quotes.
Moreover, a new type identifier 'string' is predefined.
Default \(mi.
.IP d~+/\(mi 3m
This option, if on, allows you to use variables of type 'long'.
Default \(mi.
.IP i~<num> 3m
.br
With this flag the setsize for a set of integers can be
manipulated.
The number must be the number of bits per set.
The default value is 16.
.IP l~+/\(mi 3m
If + then code is inserted to keep track of the source line number.
When this flag is switched on and off, an incorrect line number may appear
if the error occurs in a part of your program for which this flag is off.
Default +.
.IP r~+/\(mi 3m
If + then code is inserted to check subrange variables against
lower and upper subrange limits.
Default +.
.IP s~+/\(mi 3m
If + then the compiler will hunt for places in your program
where non-standard features are used, and for each place found
it will generate a warning.
Default \(mi.
.IP t~+/\(mi 3m
If + then each time a procedure is entered, the routine 'procentry' is
called, and each time a procedure exits, the procedure 'procexit' is
called.
Both 'procentry' and 'procexit' have a 'string' as parameter.
This means that when a user specifies his or her own procedures, the c-option
must be used.
Default procedures are present in the run time library.
Default \(mi.
.IP u~+/\(mi 3m
If + then the character '_' is treated like a letter,
so that it may be used in identifiers.
Procedure and function identifiers are not allowed to start with an
underscore because they may collide with library routine names.
Default \(mi.
.PP
Some of these flags (c, d, i, s, u, C and U) are only effective when
they appear before the 'program' symbol.
The others may be switched
on and off.
.PP
A very powerful debugging tool is the knowledge that inaccessible statements
and useless tests are removed by the optimizer
For instance, a
statement like:
.DS
.ft CW
if debug then
    writeln('initialization done');
.ft R
.DE
is completely removed by the optimizer if debug is a constant with
value false.
The first line is removed if debug is a constant with value true.
Of course, if debug is a variable nothing can be removed.
.SH
Library routines
.PP
The following library of external routines for Pascal programs is available:
.nf
.sp \n(PDu
.ft CW
.ta 12n
const	bufsize = ?;
.ft CW
type	br1 =  1..bufsize;
.ft CW
	br2 =  0..bufsize;
.ft CW
	br3 = -1..bufsize;
.ft CW
	ok = -1..0;
.ft CW
	buf = packed array[br1] of char;
.ft CW
	alfa = packed array[1..8] of char;
.ft CW
	string = ^packed array[1..?] of char;
.ft CW
	filetype = file of ?;
.ft CW
	long = ?;
.ft CW
.sp \n(PDu
.ft CW
{all routines must be declared extern}
.ft CW
.sp \n(PDu
.ft CW
function	argc:integer;
.ft CW
function	argv(i:integer):string;
.ft CW
function	environ(i:integer):string;
.ft CW
procedure	argshift;
.ft CW
.sp \n(PDu
.ft CW
procedure	buff(var f:filetype);
.ft CW
procedure	nobuff(var f:filetype);
.ft CW
procedure	notext(var f:text);
.ft CW
procedure	diag(var f:text);
.ft CW
procedure	pcreat(var f:text; s:string);
.ft CW
procedure	popen(var f:text; s:string);
.ft CW
procedure	pclose(var f:filetype);
.ft CW
.sp \n(PDu
.ft CW
procedure	trap(err:integer);
.ft CW
procedure	encaps(procedure p; procedure q(n:integer));
.ft CW
.sp \n(PDu
.ft CW
function	perrno:integer;
.ft CW
function	uread(fd:integer; var b:buf; len:br1):br3;
.ft CW
function	uwrite(fd:integer; var b:buf; len:br1):br3;
.ft CW
.sp \n(PDu
.ft CW
function	strbuf(var b:buf):string;
.ft CW
function	strtobuf(s:string; var b:buf; len:br1):br2;
.ft CW
function	strlen(s:string):integer;
.ft CW
function	strfetch(s:string; i:integer):char;
.ft CW
procedure	strstore(s:string; i:integer; c:char);
.ft CW
.sp \n(PDu
.ft CW
function	clock:integer;
.fi
.ft R
.PP
This library contains some often used external routines for Pascal programs.
The routines can be divided into several categories:
.PP
Argument control:
.RS
.IP argc 10
Gives the number of arguments provided when the program is called.
.PD 0
.IP argv
Selects the specified argument from the argument list and returns a
pointer to it.
This pointer is nil if the index is out of bounds (<0 or >=argc).
.IP environ
Returns a pointer to the i-th environment string (i>=0).
Returns nil
if i is beyond the end of the environment list (UNIX version 7).
.IP argshift
Effectively deletes the first argument from the argument list.
Its function is equivalent to \fIshift\fR in the UNIX shell: argv[2] becomes
argv[1], argv[3] becomes argv[2], etc.
It is a useful procedure to skip optional flag arguments.
Note that the matching of arguments and files
is done at the time a file is opened by a call to reset or rewrite.
.PD
.PP
.RE
Additional file handling routines:
.RS
.IP buff 10
Turn on buffering of a file.
Not very useful, because all
files are buffered except standard output to a terminal and diagnostic output.
Input files are always buffered.
.PD 0
.IP nobuff
Turn off buffering of an output file.
It causes the current contents of the
buffer to be flushed.
.IP notext
Only useful for input files.
End of line characters are not replaced by a space and character codes out of
the ASCII range (0..127) do not cause an error message.
.IP diag
Initialize a file for output on the diagnostic output stream (fd=2).
Output is not buffered.
.IP pcreat
The same as rewrite(f), except that you must provide the file name yourself.
The name must be zero terminated.
Only text files are allowed.
.IP popen
The same as reset(f), except that you must provide the file name yourself.
The name must be zero terminated.
Only text files are allowed.
.IP pclose
Gives you the opportunity to close files hidden in records or arrays.
All other files are closed automatically.
.PD
.PP
.RE
String handling:
.RS
.IP strbuf 10
Type conversion from character array to string.
It is your own responsibility that the string is zero terminated.
.PD 0
.IP strtobuf
Copy string into buffer until the string terminating zero byte
is found or until the buffer if full, whatever comes first.
The zero byte is also copied.
The number of copied characters, excluding the zero byte, is returned.
So if
the result is equal to the buffer length, then the end of buffer is reached
before the end of string.
.IP strlen
Returns the string length excluding the terminating zero byte.
.IP strfetch
Fetches the i-th character from a string.
There is no check against the string length.
.IP strstore
Stores a character in a string.
There is no check against
string length, so this is a dangerous procedure.
.PD
.PP
.RE
Trap handling:
.RS
These routines allow you to handle almost all
the possible error situations yourself.
You may define your own trap handler, replacing the
default handler that produces an error message and quits.
You may also generate traps yourself.
.IP trap 10
Trap generates the trap passed as argument (0..252).
The trap numbers 128..252 may be used freely.
The others are reserved.
.PD 0
.IP encaps
Encapsulate the execution of \fIp\fR with the trap handler \fIq\fR.
Encaps replaces the previous trap handler by \fIq\fR, calls \fIp\fR
and restores
the previous handler when \fIp\fR returns.
If, during the execution of \fIp\fR, a trap occurs,
then \fIq\fR is called with the trap number as parameter.
For the duration of \fIq\fR the previous trap handler is restored, so that
you may handle only some of the errors in \fIq\fR.
All the other errors must
then be raised again by a call to \fItrap\fR.
.br
Encapsulations may be nested: you may encapsulate a procedure while executing
an encapsulated routine.
.br
Jumping out of an encapsulated procedure (non-local goto) is dangerous,
because the previous trap handler must be restored.
Therefore, you may only jump out of procedure \fIp\fR from inside \fIq\fR and
you may only jump out of one level of encapsulation.
If you want to exit several levels of encapsulation, use traps.
See pc_prlib(7) for lists of trap numbers
for EM machine errors and Pascal run time system errors.
Note that \fIp\fR may not have parameters.
.PD
.PP
.RE
UNIX system calls:
.RS
.IP uread 10
Equal to the read system call.
Its normal name is blocked by the standard Pascal routine read.
.PD 0
.IP uwrite
As above but for write(2).
.IP perrno
Because external data references are not possible in Pascal,
this routine returns the global variable \fIerrno\fR, indicating the result of
the last system call.
.PD
.PP
.RE
Miscellaneous:
.RS
.IP clock 10
Return the number of ticks of user and system time consumed by the program.
.PD
.PP
.RE
The following program presents an example of how these routines can be used.
This program is equivalent to the UNIX command cat(1).
.nf
.sp \n(PDu
.ft CW
{$c+}
.ft CW
program cat(input,inp,output);
.ft CW
var	inp:text;
.ft CW
	s:string;
.sp \n(PDu
.ft CW
function argc:integer; extern;
.ft CW
function argv(i:integer):string; extern;
.ft CW
procedure argshift; extern;
.ft CW
function strlen(s:string):integer; extern;
.ft CW
function strfetch(s:string; i:integer):char; extern;
.sp \n(PDu
.ft CW
procedure copy(var fi:text);
.ft CW
var c:char;
.ft CW
begin reset(fi);
.ft CW
  while not eof(fi) do
.ft CW
  begin
.ft CW
    while not eoln(fi) do
.ft CW
    begin
.ft CW
      read(fi,c);
.ft CW
      write(c)
.ft CW
    end;
.ft CW
    readln(fi);
.ft CW
    writeln
.ft CW
  end
.ft CW
end;
.sp \n(PDu
.ft CW
begin  {main}
.ft CW
  if argc = 1 then
.ft CW
    	copy(input)
.ft CW
  else
.ft CW
    repeat
.ft CW
      s := argv(1);
.ft CW
      if (strlen(s) = 1) and (strfetch(s,1) = '-')
.ft CW
      then copy(input)
.ft CW
      else copy(inp);
.ft CW
      argshift;
.ft CW
    until argc <= 1;
.ft CW
end.
.fi
.ft R
.PP
Another example gives some idea of the way to manage trap handling:
.nf
.sp \n(PDu
.ft CW
program bigreal(output);
.ft CW
const EFOVFL=4;
.ft CW
var trapped:boolean;
.ft CW
.sp \n(PDu
.ft CW
procedure encaps(procedure p; procedure q(n:integer)); extern;
.ft CW
procedure trap(n:integer); extern;
.ft CW
.sp \n(PDu
.ft CW
procedure traphandler(n:integer);
.ft CW
begin if n=EFOVFL then trapped:=true else trap(n) end;
.ft CW
.sp \n(PDu
.ft CW
procedure work;
.ft CW
var i,j:real;
.ft CW
begin trapped:=false; i:=1;
.ft CW
  while not trapped do
.ft CW
    begin j:=i; i:=i*2 end;
.ft CW
  writeln('bigreal = ',j);
.ft CW
end;
.ft CW
.sp \n(PDu
.ft CW
begin
.ft CW
  encaps(work,traphandler);
.ft CW
end.
.fi
.ft R
.PP
Two routines may cause fatal error messages to be generated.
These are:
.IP pcreat 10
Rewrite error (trap 77) if the file cannot be created.
.PD 0
.IP popen
Reset error (trap 76) if the file cannot be opened for reading
.PD
.SH 
References
.IP [1]
BSI standard BS 6192: 1982 (ISO 7185).
.IP [2]
A.S.Tanenbaum, J.W.Stevenson, Hans van Staveren, E.G.Keizer,
"Description of a machine architecture for use with block structured languages",
Informatica rapport IR-81.
.NH 1
ABOUT THE NEW ASSEMBLER ON \*(Mp
.LP
.IP \(bu
The assembler syntax has changed for the \*(Mp.  There is a shell-script called
\fIsconv\fR, which will make most of the necessary conversions.  It is not
perfect, but works in most cases.  A list of changes follows.
.IP \(bu
If called through \fIcc\fR, files beginning with a '#' are preprocessed.
The preprocessor is not a
general preprocessor, but an ANSI-C preprocessor, so some old tricks and
some constructions may not work.
.IP \(bu
The comment symbol is now '!' instead of '|'.
.IP \(bu
The bitwise NOT in expressions is now tilde instead of '!'.
.IP \(bu
The \fI.byte\fR, \fI.word\fR and \fI.long\fR directives are now
called \fI.data1\fR, \fI.data2\fR and \fI.data4\fR respectively.
.IP \(bu
The pseudoinstruction \fI.globl\fR is now called \fI.extern\fR.
.IP \(bu
The \fIseg\fR prefix is now \fIeseg\fR, \fIcseg\fR, or \fIdseg\fR, with
no argument.
.IP \(bu
The addressing modes \fI(bx_si)\fR, \fI(bx_di)\fR, \fI(bp_si)\fR and
\fI(bp_si)\fR are now written as \fI(bx)(si)\fR, \fI(bx)(di)\fR,
\fI(bp)(si)\fR and \fI(bp)(si)\fR respectively.
.IP \(bu
The mapping of old instructions to new ones is given in the following
table.
.sp
.TS H
center, allbox;
l l.
\fBOld instruction	New instruction\fR
_
.TH
\fIin	inb
out	outb
stob	stosb
lodb	lodsb
lodw	lodsw
scab	scasb
scaw	scas
calli	callf
jmpi	jmpf
reti	retf
j	jmp
br	jmp
beq	je
bge	jge
bgt	jg
bhi	jnbe
bhis	jnb
ble	jle
blo	jb
blos	jbe
blt	jnge
bne	jne\fR
.TE
.sp
Be aware that some instructions are still valid, but now have a different
meaning.  Examples are the \fIin\fR and \fIout\fR instructions, which
will work on words instead of bytes.
.KE
.IP \(bu
The assembler knows i80286 and i80x87 instructions.
.sp 3
.NH 1
MANUAL PAGES
.LP
.nf
.CD "cc \(en C compiler"
.if t .ta 0.9i 1.25i 2.75i 3.25i 3.75i
.if n .ta 11m 16m 40m
.\" .SX "cc\fR [\fB\(enFLSTUciosvw\fR]\fR [\fB\(enD\fIname\fR] ... [\fB\(enI\fIdir\fR] ... \fIfile\fR ..."
.SX "cc\fR [\fB\(enSTOUfcimors\fR]\fR [\fB\(enw[aos]\fR] [\fB\(env[n]\fR] [\fB\(enD\fIname\fR]* [\fB\(enI\fIdir\fR]* [\fB\(enL\fIdir\fR]* \fIfile\fR+ [\fB\(enl\fIname\fR]*"
.FL "\(enD" "The flag \fB\(enD\fIx[=y]\fR defines a macro \fIx\fR with (optional) value \fIy\fR"
.FL "\(enI" "\fB\(enI\fIdir\fR searches \fIdir\fR for include files"
.FL "\(enL" "\fB\(enL\fIdir\fR searches \fIdir\fR for \fB\(enl\fIname\fR libraries"
.FL "\(enO" "Optimize the code"
.FL "\(enS" "Produce an assembly code file, then stop"
.FL "\(enT" "The flag \fB\(enT\fIdir\fR tells \fIcc\fR and \fIas\fR to use \fIdir\fR for temporary files"
.FL "\(enU" "Undefine a macro"
.FL "\(enc" "Compile only.  Do not link"
.FL "\(enf" "Link with floating point emulation library"
.FL "\(eni" "Use separate I & D space (64K + 64K) (\*(Mp only)"
.FL "\(enl" "The flag \fB\(enl\fIname\fR causes the library lib\fIname\fR.A or lib\fIname\fR.a to be linked"
.FL "\(enm" "Remove unnecessary prototypes after preprocessing (\*(Mp only)"
.FL "\(eno" "Put output on file named by next arg"
.FL "\(enr" "Do not link the default run-time start-off"
.FL "\(ens" "Strip the symbol-table from executable file"
.FL "\(env" "Verbose; print pass names"
.FL "\(envn" "\fRVerbose; print pass names but do not run them"
.FL "\(enw" "\fRSuppress warning messages"
.FL "\(enws" "\fRSuppress strict messages"
.FL "\(enwa" "\fRSuppress all warning and strict messages"
.FL "\(enwo" "\fRSuppress messages about old-style"
.EX "cc \(enc file.c" "Compile \fIfile.c\fR"
.EX "cc \(enDFOO file.c" "Treat the symbol \fIFOO\fR as defined"
.EX "cc \(enwo \(eno out file.c" "Compile old-style code; output to \fIout\fR"
.PP
This is the C compiler.
It has eight passes, as follows:
.HS
.ta 1.4i 2.1i 2.8i 3.5
   \fBProgram	Input	Output	Operation performed\fR
.br
   /lib/ncpp	prog.c	prog.i	C preprocessor: #include, #define, #ifdef
.br
   /lib/irrel	prog.i	prog.i	Removal of unnecessary prototypes
.br
   /lib/ncem	prog.i	prog.k	Parsing and semantic analysis
.br
   /lib/nopt	prog.k	prog.m	Optimization of the intermediate code
.br
   /lib/ncg	prog.m	prog.s	Code generation
.br
   /bin/as	prog.s	prog.o	Assembly
.br
   /lib/ld	prog.o	prog.out	Linking
.br
   /lib/cv	prog.out	a.out	Conversion to \*(Mx a.out format
.HS
In the 68000 versions of \*(Mx , the preprocessor is not called since the
front-end contains the preprocessor.  This increases compilation speed.
.PP
The main program,
.I cc ,
forks appropriately to call the passes, transmitting flags and arguments.
The \fB\(env\fR flag causes the passes to be listed as they are called, and
the \fB\(envn\fR flag causes the passes to be listed but not called.
.PP
The libraries should be made with \fIaal\fR (which is the same as \fIar\fR on the
68000 versions), and consist of .o files.  The internal order of files
inside the library is unimportant, but the order in which the libraries are
specified is.
.PP
.PP
When \fB\(enT\fR is used, the intermediate files end up in the directory
specified.  Otherwise,
.DI /tmp
is used.
When available memory is very limited (e.g., a 512K machine), it may be
necessary to run
.I chmem
to reduce the sizes of the compiler passes that do not fit, typically
.I ncem .
.PP
On the other hand, 
if the compiler (or, in fact, almost any program)
begins acting strange, it is almost always due to its running
out of space, either stack space or scratch file space.
The relevant pass can be given more stack space using
.I chmem .
More space for scratch files can be obtained
by removing other files on the device.
.PP
If the compiler runs out of memory, it may be necessary to use the
\fB\(enm\fR flag.  This causes
.I irrel
to be run, which removes unnecessary prototypes and thus frees up
extra table space within the compiler.
Beware, however,
that running this pass may cause strictly conforming programs to become
non-conforming and vice versa, so you should only run this pass as a last
resort.
.PP
The compiler is derived from the ACK system (Tanenbaum et 
al., \fICommunications of the ACM\fR, Sept. 1983),
not from the AT&T portable C compiler.
It has been shoehorned onto the PC with some loss of performance.



.LP
.nf
.CD "m2 \(en Modula-2 compiler"
.if t .ta 0.9i 1.35i 2.75i 3.25i 3.75i
.if n .ta 11m 16m 40m
.SX "m2\fR [\fB\(enSTORA3fcniors\fR]\fR [\fB\(en[wW][OR]\fR] [\fB\(env[n]\fR] [\fB\(enI\fIdir\fR]* [\fB\(enL\fIdir\fR]* \fIfile\fR+ [\fB\(enl\fIname\fR]*"
.FL "\(enI" "\fB\(enI\fIdir\fR searches \fIdir\fR for definition modules"
.FL "\(enL" "\fB\(enL\fIdir\fR searches \fIdir\fR for \fB\(enl\fIname\fR libraries"
.FL "\(enR" "Disable runtime checks"
.FL "\(enA" "Enable array bound checks"
.FL "\(enO" "Optimize the code"
.FL "\(enS" "Produce an assembly code file, then stop"
.FL "\(enT" "The flag \fB\(enT\fIdir\fR tells \fIm2\fR and \fIas\fR to use \fIdir\fR for temporary files"
.FL "\(en3" "Only accept 3rd edition Modula-2"
.FL "\(enn" "Disable file name and line number administration"
.FL "\(enc" "Compile only.  Do not link"
.FL "\(enf" "Link with floating point emulation library"
.FL "\(eni" "Use separate I & D space (64K + 64K) (\*(Mp only)"
.FL "\(enl" "The flag \fB\(enl\fIname\fR causes the library lib\fIname\fR.A or lib\fIname\fR.a to be linked"
.FL "\(eno" "Put output on file named by next arg"
.FL "\(enr" "Do not link the default run-time start-off"
.FL "\(ens" "Strip the symbol-table from executable file"
.FL "\(env" "Verbose; print pass names"
.FL "\(envn" "\fRVerbose; print pass names but do not run them"
.FL "\(enw" "\fRSuppress warning messages"
.FL "\(enwO" "\fRSuppress warning messages about old-fashioned use"
.FL "\(enWR" "\fREnable strict warning messages"
.EX "m2 \(enc file.mod" "Compile \fIfile.mod\fR"
.PP
This is the Modula-2 compiler.
It has six passes, as follows:
.HS
.ta 1.4i 2.1i 2.8i 3.5
   \fBProgram	Input	Output	Operation performed\fR
.br
   /lib/nm2em	prog.mod	prog.k	Parsing and semantic analysis
.br
   /lib/nopt	prog.k	prog.m	Optimization of the intermediate code
.br
   /lib/ncg	prog.m	prog.s	Code generation
.br
   /bin/as	prog.s	prog.o	Assembly
.br
   /lib/ld	prog.o	prog.out	Linking
.br
   /lib/cv	prog.out	a.out	Conversion to \*(Mx a.out format
.HS
The main program,
.I m2 ,
forks appropriately to call the passes, transmitting flags and arguments.
The \fB\(env\fR flag causes the passes to be listed as they are called, and
the \fB\(envn\fR flag causes the passes to be listed but not called.
.PP
Usually, a Modula-2 program consists of several definition and implementation
modules, and one program module.
Definition modules must reside in files with names having a '.def' extension.
Implementation modules and program modules must reside in files having a
'.mod' extension.
.PP
The name of the file in which a definition module is stored must be the same as
the module-name, apart from the extension.
Also, in most Unix systems file names are only 14 characters long.
So, given an IMPORT declaration for a module called 'LongModulName',
the compiler will try to open a file called 'LongModulN.def'.
The requirement does not hold for implementation or program modules,
but is certainly recommended.
.PP
To compile an implementation module, use the \-\fBc\fR flag
to produce a '.o' file.
Definition modules can not be compiled; the compiler reads them when they are
needed.
.PP
The 'standard' definition modules can be found in
the directory \fI/usr/lib/m2\fR.
.PP
When the compiler needs a definition module, it is first searched for
in the current directory, then in the directories given to it by the
\-\fBI\fR flag
in the order given,
and then in the directory mentioned above.
.PP
The libraries should be made with aal (which is the same as \fIar\fR on the
68000 versions), and consist of .o files.  The internal order of files
inside the library is unimportant, but the order in which the libraries are
specified is.
.PP
When \fB\(enT\fR is used, the intermediate files end up in the directory
specified.  Otherwise,
.DI /tmp
is used.
When available memory is very limited (e.g., a 512K machine), it may be
necessary to run
.I chmem
to reduce the sizes of the compiler passes that do not fit, typically
.I nm2em .
.PP
On the other hand, 
if the compiler (or, in fact, almost any program)
begins acting strange, it is almost always due to its running
out of space, either stack space or scratch file space.
The relevant pass can be given more stack space using
.I chmem .
More space for scratch files can be obtained
by removing other files on the device.
.PP
The compiler is derived from the ACK system (Tanenbaum et 
al., \fICommunications of the ACM\fR, Sept. 1983).
It has been shoehorned onto the PC with some loss of performance.



.LP
.nf
.CD "pc \(en Pascal compiler"
.if t .ta 0.9i 1.25i 2.75i 3.25i 3.75i
.if n .ta 11m 16m 40m
.SX "pc\fR [\fB\(enSTORAafcniorsw\fR]\fR [\fB\(env[n]\fR] [\fB\(enL\fIdir\fR]* \fIfile\fR+ [\fB\(enl\fIname\fR]*"
.FL "\(enL" "\fB\(enL\fIdir\fR searches \fIdir\fR for \fB\(enl\fIname\fR libraries"
.FL "\(enR" "Disable runtime checks"
.FL "\(enA" "Enable array bound checks"
.FL "\(enO" "Optimize the code"
.FL "\(enS" "Produce an assembly code file, then stop"
.FL "\(enT" "The flag \fB\(enT\fIdir\fR tells \fIpc\fR and \fIas\fR to use \fIdir\fR for temporary files"
.FL "\(ena" "Enable assertions"
.FL "\(enn" "Disable file name and line number administration"
.FL "\(enc" "Compile only.  Do not link"
.FL "\(enf" "Link with floating point emulation library"
.FL "\(eni" "Use separate I & D space (64K + 64K) (\*(Mp only)"
.FL "\(enl" "The flag \fB\(enl\fIname\fR causes the library lib\fIname\fR.A or lib\fIname\fR.a to be linked"
.FL "\(eno" "Put output on file named by next arg"
.FL "\(enr" "Do not link the default run-time start-off"
.FL "\(ens" "Strip the symbol-table from executable file"
.FL "\(env" "Verbose; print pass names"
.FL "\(envn" "Verbose; print pass names but do not run them"
.FL "\(enw" "Suppress warning messages"
.EX "pc \(enc file.p" "Compile \fIfile.p\fR"
.PP
This is the Pascal compiler.
It has six passes, as follows:
.HS
.ta 1.4i 2.1i 2.8i 3.5
   \fBProgram	Input	Output	Operation performed\fR
.br
   /lib/npem	prog.p	prog.k	Parsing and semantic analysis
.br
   /lib/nopt	prog.k	prog.m	Optimization of the intermediate code
.br
   /lib/ncg	prog.m	prog.s	Code generation
.br
   /bin/as	prog.s	prog.o	Assembly
.br
   /lib/ld	prog.o	prog.out	Linking
.br
   /lib/cv	prog.out	a.out	Conversion to \*(Mx a.out format
.HS
The main program,
.I pc ,
forks appropriately to call the passes, transmitting flags and arguments.
The \fB\(env\fR flag causes the passes to be listed as they are called, and
the \fB\(envn\fR flag causes the passes to be listed but not called.
.PP
When \fB\(enT\fR is used, the intermediate files end up in the directory
specified.  Otherwise,
.DI /tmp
is used.
When available memory is very limited (e.g., a 512K machine), it may be
necessary to run
.I chmem
to reduce the sizes of the compiler passes that do not fit, typically
.I npem .
.PP
On the other hand, 
if the compiler (or, in fact, almost any program)
begins acting strange, it is almost always due to its running
out of space, either stack space or scratch file space.
The relevant pass can be given more stack space using
.I chmem .
More space for scratch files can be obtained
by removing other files on the device.
.PP
The compiler is derived from the ACK system (Tanenbaum et 
al., \fICommunications of the ACM\fR, Sept. 1983).



.CD "m2mm \(em Modula-2 makefile generator"
.SX "m2mm\fR [\fB\(enI\fIdir\fR] [\fB\(enL\fIdir\fR] [\fB\(enl\fIlib\fR] [\fB\(enM\fIflags\fR] [\fB\(enC\fIcomp\fR] \fIfile\fR+
.FL "\(enI" "Searches \fIdir\fR for definition modules (see below)"
.FL "\(enL" "Searches \fIdir\fR for definition modules (see below)"
.FL "\(enM" "Set compiler flags to \fIflags\fR (see below)"
.FL "\(enC" "Set compiler to \fIcomp\fR (see below)"
.FL "\(enl" "Add \fIlib\fR to loader arguments"
.EX "m2mm *.mod" "Produce makefile for all .mod files in ."
.PP
\fIM2mm\fR
is a makefile generator and fast syntax checker for Modula-2 programs.
It will generate rules to produce an object file
for every module used in the argument files.
In addition, it will generate a rule to make a program, for each of the
program modules given as argument.
The makefile is produced on standard output.
.PP
In the makefile, the variables \fBMOD\fR, \fBM2FLAGS\fR, \fBIFLAGS\fR,
\fBLIBS\fR, and \fBSUFFIX\fR will be defined.
The generated rules have the following form:
.IP "\fIname\fR.$(SUFFIX): ..."
.br
$(MOD) -c $(M2FLAGS) $(IFLAGS) \fIname\fR.mod
.PP
The directories given with the \fB\(enI\fR or the \fB\(enL\fR flags are added
to \fBIFLAGS\fR.
The difference between the \fB\(enL\fR and the \fB\(enI\fR flag is, that the \fB\(enL\fR directories are considered
interfaces to libraries, and thus no rules are generated using or creating
object files for modules found in these directories.
Instead, the user is
expected to add a library to the \fBLIBS\fR macro, using the \fB\(enl\fR flag.
.PP
The default value for \fBMOD\fR is \fIm2\fR.
It can be changed using the
\fB\(enC\fR flag.



.CD "as \(en assembler"
.SX "as\fR [\fB\(en\fR] [\fB\(enbu\fR] [\fB\(eno \fIname\fR] [\fB\(ens\fIn\fR]"
.FL "\(enb" "Turn off branch optimization"
.FL "\(eno" "Output is put on file \fIname\fR"
.FL "\(ens" "Controls symbolic debug output (see below)"
.FL "\(enu" "Treat undefined symbols as \fI.extern\fR"
.FL "\(en" "Same as \fB\(enu\fR"
.EX "as file.s" "Assemble file.s"
.EX "as \(en file1.s file2.s" "Treat undefined symbols as \fI.extern\fR"
.PP
\fIAs\fR assembles symbolic assembly programs (\fI.s\fR files) to 
relocatable object modules (\fI.o\fR files), the same as most assemblers do.
The assembly language accepted is a modified version of \s-2XENIX\s0 for
\*(Mp, and the object format is the standard ACK format for the 68000
versions of \*(Mx.
The \fB\(ens\fR option controls the amount of symbolic debug 
information generated.
.I n
is interpreted as an octal number.  The bits have the following meaning:
.nf
.HS
     001: external symbols
     002: local symbols
     004: local, compiler generated labels
     010: symbols defined in \fI.symb\fR pseudo instruction
     020: records for \fI.line\fR and \fI.file\fR statements
     040: section names
.HS
.fi
Default is 073: all except local compiler labels.




.CD "ld \(en linker"
.SX "ld\fR [\fB\(enirs\fR]"
.FL "\(eni" "Use separate I & D space [PC]"
.FL "\(enr" "Generate relocation information in output file"
.FL "\(ens" "Strip off symbol table"
.EX "ld file.o" "Load file.o"
.PP
\fILd\fR is the loader.
It takes one or more relocatable object modules (\fI.o\fR files) and
builds an output file in ACK format.
This output file can be converted to 
.MX
\fIa.out\fR format using \fIcv\fR.




.CD "aal \(en archiver"
.SX "aal\fR [\fBdartx\fR][\fBclv\fR]\fR \fIarchive \fIfile ..."
.FL "\fR(none)"
.EX "aal r libc.A qsort.o" "Replace \fIqsort\fR.o in \fIlibc.A\fR"
.PP
\fIAal\fR allows groups of files to be put together into a single
archive.  It is normally used for libraries of compiled procedures, but
can also be used for other archives.  An index-table is automatically
maintained.  The linker only understands archives made with \fIaal\fR.
This is the same archiver as the \fIar\fR that is 
supplied with 68000 versions of \*(Mx.
The following keys are allowed:

.HS
.ta 0.25i 0.50i
.nf
	\fBd\fR:	Delete. \fIAal\fR will delete the named members.
	\fBa\fR:	Append the named files to the archive.
	\fBr\fR:	Replace (append when not in archive).
	\fBt\fR:	Print the archive's table of contents.
	\fBx\fR:	Extract
.fi
.HS
The keys may optionally concatenated with one or more of the following:
.nf
.HS
	\fBc\fR:	Create  (suppresses creation message)
	\fBl\fR:	Temporaries in current directory instead of \fI/tmp\fR
	\fBv\fR:	Verbose
.HS
.fi




.CD "asize \(en report the size of an object file"
.SX "asize \fIfile\fR ..."
.FL "\fR(none)"
.EX "asize test.o" "Give the size of \fItest.o\fR"
.PP
.I Asize
prints for each argument
the (decimal) number of bytes used by the different sections,
as well as their sum in decimal and hexadecimal.
If no
.I file
is given \fIa.out\fR is used.
.I Asize
can only be used to obtain the size of a \(M2 \fI.o\fR or \fI.out\fR file. 
To obtain the size of an executable, use
.I size
instead.




.CD "astrip \(en remove symbols"
.SX "astrip \fIfile\fR ..."
.FL "\fR(none)"
.EX "astrip kernel.out" "Removes the symbol table from \fIkernel.out\fR"
.PP
.I Astrip
removes the symbol table ordinarily attached to
ACK format object files.
.I Astrip
can only be used to remove the symbol table from a 
.MX
\fI.out\fR file. 
It cannot be used to remove symbol tables from executables.
To do that use
.I strip
instead.




.CD "anm \(en print name list"
.SX "anm \fR[\fB\(engnoprus\fR] \fIfile\fR ..."
.FL "\(eng" "Global symbols only"
.FL "\(enn" "Sort numerically"
.FL "\(eno" "Prepend the filename to each line"
.FL "\(enp" "No sorting\(emuse symbol table order"
.FL "\(enr" "Sort in reverse order"
.FL "\(enu" "List undefined symbols only"
.FL "\(ens" "Sort in section order"
.EX "anm  \(engn  test.o" "Print global symbols in numerical order"
.PP
.I Anm
prints the name list (symbol table) of each ACK format object
.I file
in the argument list.
If no file name is given, \fIa.out\fR is used.
Each symbol name is preceded by its value, a section indicator
and a type indicator.
The section indicators are:
.SP 0.7
.HS
.ta 0.25i 0.50i
.nf
	\fBU\fR	Undefined symbol
	\fBA\fR	Absolute symbol
	\fBC\fR	Common symbol
	\fB\(en\fR	Other symbol
.sp
The type indicators are:
.HS
	\fBF\fR	Filename
	\fBM\fR	Module name
	\fBS\fR	Section name
	\fBE\fR	External (global) symbol
	\fB\(en\fR	Local symbol
.fi
.PP
The output is sorted alphabetically, unless otherwise specified.
Notice that \fIanm\fR can only be used on ACK format object files 
(that is: \fI.o\fR and \fI.out\fR files). 
If you want to get the name list of an executable program use 
.I nm
instead.




.CD "aoutdump \(en display the contents of an object file"
.SX "aoutdump \fR[\fIfile\fR [\fIabcdef\fR] ]"
.FL "\fR(none)"
.EX "aoutdump test.o 000010" "dump the symbol table records of \fItest.o\fR"
.PP
.I Aoutdump
gives a complete dump of each ACK formatted object
.I file
in the argument list.
If no
.I file
is given, \fIa.out\fR is displayed.
The parameter following the file name is a bit map that
can be used to specify a partial dump.
Each bit must be 0 or 1.
The 6 bits in the map have the following meanings:
.HS
.ta 0.25i 0.50i
.nf
	\fIa\fR	Display the header record
	\fIb\fR	Display the section records
	\fIc\fR	Display the code bytes
	\fId\fR	Display the relocation records
	\fIe\fR	Display the symbol table records
	\fIf\fR	Display the string area
.fi
